{
  "name": "dinistiq",
  "tagline": "Minimalistic Dependency Injection - Or: what I got wrong about dependency injection. dinistiq is a minimalistic approach to component based application setup done in Java. With only few external dependencies and a very small footprint it is based on the JSR 330 annotations for the Java SE using only one scope with mostly singletons.",
  "body": "![dinistiq](https://raw.github.com/mgoellnitz/dinistiq/master/doc/dinistiq.png)\r\n\r\n# Minimalistic Dependency Injection\r\n\r\n[![Latest Release](https://img.shields.io/github/release/mgoellnitz/dinistiq.svg)](https://github.com/mgoellnitz/dinistiq/releases/latest)\r\n[![Build Status](https://api.travis-ci.org/mgoellnitz/dinistiq.svg?branch=master)](https://travis-ci.org/mgoellnitz/dinistiq)\r\n[![Coverage Status](https://coveralls.io/repos/github/mgoellnitz/dinistiq/badge.svg?branch=master)](https://coveralls.io/github/mgoellnitz/dinistiq?branch=master)\r\n[![Coverage Status](http://codecov.io/github/mgoellnitz/dinistiq/coverage.svg?branch=master)](https://codecov.io/gh/mgoellnitz/dinistiq)\r\n[![Dependency Status](https://www.versioneye.com/user/projects/54ff710b4a10649b1b000053/badge.svg?style=flat)](https://www.versioneye.com/user/projects/54ff710b4a10649b1b000053)\r\n\r\nA small footprint approach to dependency injection with a framework or container\r\nimplemented in Java.\r\n\r\nOr: What I got wrong about DI\r\n\r\nMinimalistic library to use dependency injection for the wire-up of software \r\ncomponents. It thus mostly deals with singletons - some of them implementing \r\ninterfaces - which should be injected as dependencies into one another taking \r\ninto account their  name, qualifier.\r\n\r\nAs the only other option besides the single scope managed by dinistiq it allows \r\nfor the creation of fresh instances with all dependencies filled in from the \r\nscope of all beans collected.\r\n\r\n## Fire up the wire up\r\n\r\nDinistiq scans a given portion of the classpath for classes annotated with \r\nJSR330 Annotations. It does not introduce any custom annotations.\r\n\r\nThe missing bits can be configured by a set of properties files, describing\r\n\r\n- additional components that should be instanciated\r\n- additional values that should be injected into the instanciated components but cannot be derived from the autoscanned parts\r\n\r\n## Convention over Configuration\r\n\r\nFirst of all the most important thing to use dinistiq is to annotate your \r\ndependencies with JSR @Inject so that dinistiq can find out which components are \r\nneeded.\r\n\r\n```Java\r\npublic class TestComponentB {\r\n\r\n    @Inject\r\n    public TestInterface test;\r\n\r\n} // TestComponentB\r\n```\r\n\r\nIn the next step dinistiq resolves those components from the auto-scanned \r\nportion of the classpath where it instanciates all classes annotated with \r\n@Singleton. Optionally these components may be named with @Named (with an \r\noptional name as the value parameter). Without a name given as a parameter, \r\ncomponents are always named after their class name without the package name and \r\na decapitalized first letter.\r\n\r\n```Java\r\n@Singleton\r\npublic class TestComponent implements TestInterface {\r\n\r\n} // TestComponent\r\n```\r\n\r\nThus in this example the instanciated bean of class TestComponent will be \r\navailable with the name testComponent. The term \"name\" is used in this document \r\nsince it is used as the parameter name in the JSR330 annotations. Since names \r\nmust be unique within the scope they are in this case in fact identifiers \r\nthrougout the whole process.\r\n\r\nIf you are dealing with components of the same type, not only the beans may be \r\nnamed but also the injection point might indicate to require a bean with a \r\ncertain name.\r\n\r\n```Java\r\npublic class ConfigStuff {\r\n\r\n    @Inject\r\n    @Named\r\n    public String filename;\r\n\r\n    @Inject\r\n    @Named(\"prefix\")\r\n    public String somePrefix;\r\n\r\n} // ConfigStuff\r\n```\r\n\r\nIn this case, filename is searched as a String component with the name \"filename\",\r\nwhile somePrefix has a specific named annotation with value \"prefix\".\r\n\r\nThis complete set-up is done without any configuration for dinistiq itself but \r\nonly for the components to be used.\r\n\r\n## Configuration through annotations\r\n\r\nJSR330 specifies the concept of qualifiers to select which implementation of\r\nan interface is to be chosen. Unfortunately this means, that the injection\r\npoint defines which implementation is chosen in the Java code. So we recommend\r\nnot to use this in your code but add configuration files (see below) to control\r\nthe selection of implementing classes outside the code.\r\n\r\nYou may defined annotations describing qualifiers\r\n\r\n```Java\r\n@Qualifier\r\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface TestQualifier {\r\n} // TestQualifier\r\n```\r\n\r\nand these qualifiers may be used to define injection criteria at the injection\r\npoints.\r\n\r\n```Java\r\npublic class QualifiedInjection {\r\n\r\n    @Inject\r\n    @TestQualifier\r\n    private TestInterface testInterface;\r\n\r\n} // QualifiedInjection\r\n```\r\n\r\nOnly implementation annotated with the given qualifier are take into account\r\nwhen performing the injection.\r\n\r\n```Java\r\n@Singleton\r\n@TestQualifier\r\npublic class QualifiedComponent implements TestInterface {\r\n\r\n} // QualifiedComponent\r\n```\r\n\r\n\r\n## Optional Configuration with properties files\r\n\r\nIf this is not enough, you can explicitly add some beans to be instanciated in \r\nproperties files.\r\n\r\n```\r\nunannotatedComponent=dinistiq.test.components.UnannotatedComponent\r\n```\r\n\r\nThose files must simply be put in the folder dinistiq/ anywhere on your classpath.\r\nThis example will instanciate the class dinistiq.test.components.UnannotatedComponent\r\nand store this bean with the name unannotatedComponent in the set of available \r\nbeans.\r\n\r\nThe properties files are scanned in alphabetical order, so you can override the \r\nclass for e.g. unannotatedComponent in a latter properties file, so classes given \r\nfor bean names used in mybeans.properties can be overridden in override-mybeans.properties.\r\n\r\nFor any of the instanciated beans you can provide more values to explicitly \r\ninject - again by the use of properties files.\r\n\r\nAfter instanciation of the bean a properties file with the bean's name as its \r\nbase filename is searched - first in the dinistiq/defaults/ and then in the \r\ndinistiq/beans/ folders on the classpath. Thus you can deliver your components \r\nwith a reasonable defaults and necessary overrides for the specific application.\r\n\r\nfile dinistiq/beans/example.properties\r\n```\r\nactivateCaching=true\r\n```\r\n\r\nThis will call the property setter setActivateCaching() on the bean named \r\nexample. The grammar of the properties files describing the explicit injection \r\nsupports set and list type collections, boolean values, numeric value, strings, \r\nand references to other beans.\r\n\r\nfile dinistiq/beans/example.properties\r\n```\r\n# numerics\r\nintValue=42\r\nlongValue=123456789\r\nfloatValue=3.14159\r\ndoubleValue=2.7\r\n# references\r\ntestInterface=${testComponent}\r\n# strings and references in compound strings\r\nreplacement=a string\r\nreplacementTest=here comes ${replacement}\r\n```\r\n\r\nThe bean named example is either a result of the automatic discovery of a class \r\nnamed Example\r\n\r\n```Java\r\n@Named\r\n@Singleton\r\npublic class Example {\r\n\r\n} // Example\r\n```\r\n\r\na name declaration from the scanned class\r\n\r\n```Java\r\n@Named(\"example\")\r\n@Singleton\r\npublic class ExampleComponent  {\r\n\r\n} // ExampleComponent\r\n```\r\n\r\nor taken from the naming in a configuration properties file\r\n\r\nfile dinistiq/demo.properties\r\n```\r\nexample=some.package.ExampleComponent\r\n```\r\n\r\nAt the top level, the types of the beans cannot be inferred, as the example\r\n\r\n```\r\nunannotatedComponent=dinistiq.test.components.UnannotatedComponent\r\n```\r\n\r\nshowed. If you need some typical configuration types at this level - like e.g. \r\nStrings, Booleans, Lists, and Maps some extensions of this mere class based \r\nsyntax had to be introduced. Any simple type found in the java.lang package can \r\nbe intanciated with a value bound to it since these values are immutable and \r\nthere are thus no modifiable fields or setters in these classes.\r\n\r\nSo\r\n\r\n```\r\nbooleanValue=java.lang.Boolean(\"false\")\r\nstringValue=java.lang.String(\"string value\")\r\nintegerValue=java.lang.Integer(42)\r\n```\r\n\r\nare some examples for this. While\r\n\r\n```\r\nmapTest=java.util.Map\r\n```\r\n\r\ncreates and empty map instance. Like any other beans the contents of this map can\r\nbe modified by a properties file. In this case the contents of the properties \r\nfile's key / value pairs will be used as content for the whole map.\r\n\r\nLists of strings can be created by\r\n\r\n```\r\nlistTest=java.util.List(first,second)\r\n```\r\n\r\n## How to use\r\n\r\nExtend your project with the dependency to the rather small dinistiq library \r\nfile. Dinistiq releases are available from JCenter. The group id and artifact id \r\nare both 'dinistiq'.\r\n\r\nThus for projects built with gradle you will need to add to your repositories \r\nsections of the build file the line\r\n\r\n```\r\njcenter()\r\n```\r\n\r\nif it's not there already and the dependency to the artifact in the dependencies \r\nsection.\r\n\r\n```\r\ncompile \"dinistiq:dinistiq:0.6\"\r\n```\r\n\r\nProjects built with Apache Maven need the following steps:\r\n\r\nmodule pom.xml\r\n```xml\r\n...\r\n<dependencies>\r\n  ...\r\n  <dependency>\r\n    <groupId>dinistiq</groupId>\r\n    <artifactId>dinistiq</artifactId>\r\n  </dependency>\r\n  ...\r\n</dependencies>\r\n```\r\n\r\nbase  pom.xml\r\n```xml\r\n...\r\n<dependencyManagement>\r\n  ...\r\n  <dependency>\r\n    <groupId>dinistiq</groupId>\r\n    <artifactId>dinistiq</artifactId>\r\n    <versions>0.6</version>\r\n  </dependency>\r\n...\r\n</dependencyManagement>\r\n\r\n...\r\n\r\n<repositories>\r\n  <repository>\r\n    <id>jcenter</id>\r\n    <name>JCenter</name>\r\n    <url>http://jcenter.bintray.com/</url>\r\n  </repository>\r\n</repositories>\r\n...\r\n```\r\n\r\nDinistiq uses slf4j for logging and logback as an instance for testing.\r\n\r\nSnapshot artifacts are available from the OJO repository:\r\n\r\n```\r\nhttps://oss.jfrog.org/oss-snapshot-local/\r\n```\r\n\r\nApart from optional configuration files to be placed somehere on your classpath,\r\nyou simply have to tell dinistiq which portion of the classpath to scan for \r\nannotations.\r\n\r\n```Java\r\npublic class Test  {\r\n\r\n    public static main(String[] args) {\r\n        Set<String> packages = new HashSet<String>();\r\n        packages.add(Test.class.getPackage().getName());\r\n        Dinistiq d = new Dinistiq(packages);\r\n    } // main()\r\n\r\n} // Test\r\n```\r\n\r\nMake this portion of the classpath as small as ever possible or point to some \r\ninvented and thus empty package, if you want to avoid scanning.\r\n\r\nAfter this step you can ask dinistiq for instances of the components it created \r\nand injected.\r\n\r\n```Java\r\npublic class Test  {\r\n\r\n    public static main(String[] args) {\r\n        Set<String> packages = new HashSet<String>();\r\n        packages.add(Test.class.getPackage().getName());\r\n        Dinistiq d = null;\r\n        try {\r\n            d = new Dinistiq(packages);\r\n        } catch (Exception e) {\r\n            //\r\n        } // try/catch\r\n        TestInterface ti = d.findTypedBean(TestInterface.class);\r\n        TestInterface test = d.findBean(TestInterface.class, \"test\");\r\n        Set<TestInterface> tis = d.findTypedBeans(TestInterface.class);\r\n    } // main()\r\n\r\n} // Test\r\n```\r\n\r\n## Web embedding\r\n\r\nDinistiq comes with a very lean web integration. An ordered list of beans \r\nimplementing the servlet interface will be registered directly with the servlet \r\ncontainer.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\r\n         version=\"3.1\">\r\n\r\n  <display-name>dinistiq.web</display-name>\r\n\r\n  <listener>\r\n    <listener-class>dinistiq.web.DinistiqContextLoaderListener</listener-class>\r\n  </listener>\r\n  <context-param>\r\n    <param-name>dinistiq.packages</param-name>\r\n    <param-value>com.example.components,org.example.components</param-value>\r\n  </context-param>\r\n\r\n  <welcome-file-list>\r\n    <welcome-file>index.html</welcome-file>\r\n  </welcome-file-list>\r\n\r\n</web-app>\r\n```\r\n\r\nThe context loader listener tries to find the servlets from the dinistiq context \r\nby asking for RegisterableServlet instances.\r\n\r\n```Java\r\n/**\r\n * Servlets which should handle requests fulfilling a certain regular expression for their uris.\r\n */\r\npublic interface RegisterableServlet extends Servlet, Comparable<RegisterableServlet> {\r\n\r\n    /**\r\n     * Returns a set of url patterns this servlet should be registered for.\r\n     */\r\n    Set<String> getUrlPatterns();\r\n\r\n    /**\r\n     * Indicator if the implementing instance should be considered earlier or later\r\n     * in the servlet selection process.\r\n     */\r\n    int getOrder();\r\n\r\n} // RegisterableServlet\r\n```\r\n\r\nSo a servlet has to tell which url patterns its request should meet to be able to\r\nhandle them. Additionally it tells an order number to sort all available servlets\r\nto provide a certain precedency rule for them.\r\n\r\n## Custom Class Resolver\r\n\r\nIt is perfectly possible that you will find our class resolving pretty dumb. So \r\nwe provide the option to pass over a class resolver instance to dinistiq instead \r\nof the set of package names.\r\n\r\n```Java\r\npublic class Test  {\r\n\r\n    public static main(String[] args) {\r\n        Set<String> packages = new HashSet<String>();\r\n        packages.add(Test.class.getPackage().getName());\r\n        packages.add(Dinistiq.class.getPackage().getName());\r\n        Dinistiq d = null;\r\n        ClassResolver classResolver = new BetterClassResolver(packages);\r\n        try {\r\n            d = new Dinistiq(classResolver);\r\n        } catch (Exception e) {\r\n            //\r\n        } // try/catch\r\n    } // main()\r\n\r\n} // Test\r\n```\r\n\r\nBe sure to add the package dinistiq in these cases as shown above. Otherwise for \r\nobvious reasons the properties files from the dinistiq path cannot be found as \r\nresources to be taken into consideration.\r\n\r\nIf you want to use custom class resolvers with the web integration you need to \r\nimplement a class resolver taking the set of package names as the single parameter \r\nto the constructor and put the name of this implementing class in the context \r\nloader listener configuration for dinistiq.\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\r\n         version=\"3.1\">\r\n\r\n  <display-name>dinistiq.web</display-name>\r\n\r\n  <listener>\r\n    <listener-class>dinistiq.web.DinistiqContextLoaderListener</listener-class>\r\n  </listener>\r\n  <context-param>\r\n    <param-name>dinistiq.packages</param-name>\r\n    <param-value>com.example.components,org.example.components</param-value>\r\n  </context-param>\r\n  <context-param>\r\n    <param-name>dinistiq.class.resolver</param-name>\r\n    <param-value>org.example.dinistiq.BetterClassResolver</param-value>\r\n  </context-param>\r\n\r\n  <welcome-file-list>\r\n    <welcome-file>index.html</welcome-file>\r\n  </welcome-file-list>\r\n\r\n</web-app>\r\n```\r\n\r\nWithin the web application all beans from the dinistiq scope are available in the\r\napplication scope (servlet context) as attributes.\r\n\r\n## External Components\r\n\r\nIf your software needs to use some components which cannot be instanciated or \r\nobtained using all of the means presented here, you can pass over a named set of \r\ninstances as a base set of beans for dinistiq to add the scanned and configured \r\nbeans to.\r\n\r\nWe use this to e.g. put the servlet context in the set of beans for web \r\nintegration (see below).\r\n\r\n```Java\r\npublic class DinistiqContextLoaderListener implements ServletContextListener {\r\n\r\n    @Override\r\n    public void contextInitialized(ServletContextEvent contextEnvironment) {\r\n        ServletContext context = contextEnvironment.getServletContext();\r\n        Set<String> packages = new HashSet<String>();\r\n        ...\r\n        try {\r\n            Map<String, Object> externalBeans = new HashMap<String, Object>();\r\n            externalBeans.put(\"servletContext\", context);\r\n            Dinistiq dinistiq = new Dinistiq(packages, externalBeans);\r\n            context.setAttribute(DINISTIQ_INSTANCE, dinistiq);\r\n        } catch (Exception ex) {\r\n            LOG.error(\"init()\", ex);\r\n        } // try/catch\r\n    } // contextInitialized()\r\n\r\n} // DinistiqContextLoaderListener\r\n```\r\n\r\n## Besides the one managed Scope\r\n\r\nDinistiq defines just one scope of beans you can grab beans from. If you need \r\nfresh instances of beans where the members of this scope should be injected on \r\ncreation and optional post construct methods should be called just following the \r\nsame rules as the beans from the dinistiq scope, you will find a createBeans \r\nmethod besides all the options to find existing beans in the scope.\r\n\r\n```Java\r\nMy myNewInstance = dinistiq.createBean(My.class, null);\r\n```\r\n\r\nIf this is still no option, you can - like with external beans - provide instances\r\nexternally and let dinistiq still handle their injections and post construct \r\nmethods.\r\n\r\n```Java\r\nMy myNewInstance = new My();\r\ndinistiq.initBean(myNewInstance, null);\r\n```\r\n\r\n## Building\r\n\r\nWhile dinistiq 0.4 happily works with Java 8, only dinistiq 0.5 and up can be \r\ncompiled and tested with Java 8.\r\n\r\nThe code for dinistiq is prepared for building with Gradle. Gradle 2 versions up \r\nto 2.14.1 are tested to be working, while dinistiq starting from version 0.7\r\nat least needs Gradle 2.12.\r\n\r\nUp to dinistiq 0.5 the code is supposed to be written in Java 7 with a subsequent\r\nswitch to Java 8.\r\n\r\n|dinistiq Version|Works with |Compiles with|GAE support|\r\n|:--------------:|:---------:|:-----------:|:---------:|\r\n|0.4|Java 7 / 8|Java 7|+|\r\n|0.5|Java 7 / 8|Java 7 / 8|-|\r\n|0.6|Java 8|Java 8|-|\r\n|0.7|Java 8|Java 8|-|\r\n\r\n## Comparison\r\n\r\nThe developer of [SilkDI](https://github.com/jbee/silk/blob/6a739b44973de964013d320c174a333e2f70665c/help/comparison.md) presents an\r\ninteresting comparison of some DI implementations done in Java and we want to add\r\nsome  values for dinistiq to this list:\r\n\r\n|Library|dinistiq|\r\n|:------|-------:|\r\n|Version|0.7|\r\n|Archive size|24kB|\r\n|Further dependencies|3|\r\n|API||\r\n|Methods in injector/context|10|\r\n|Concept||\r\n|Container Model|flat instances|\r\n|Configuration style|annotation,properties|\r\n|Wiring style|automatic scan|\r\n|Types||\r\n|Generics support|limitted|\r\n|Generic type safety|-|\r\n|Wildcard generics|-|\r\n|Primitive types handling|-|\r\n|Bind to all (generic) supertypes|yes|\r\n|Type link|-|\r\n|Injection||\r\n|Annotation guidance|only JSR330|\r\n|Constructor injection|yes|\r\n|Field injection|yes|\r\n|Setter injection|yes|\r\n|Factory methods|no|\r\n|Static injection|yes|\r\n|Method interception|no|\r\n|Providers|(limited)|\r\n|Optional injection|yes|\r\n|Mixed injection|?|\r\n|Post construction hook|yes|\r\n|Modularity||\r\n|Arrays|no|\r\n|Collections|partly|\r\n|Multibinds|yes|\r\n|Sequence of declarations|undefined|\r\n|Scopes|limited|\r\n|Default scope|Singleton|\r\n|Custom scopes|-|\r\n|Available scopes|Singleton|\r\n|Error behaviour||\r\n|Dependency cycles|illegal|\r\n|Detection of a cyclic dependencies error|runtime|\r\n\r\nThe closest competitor of dinistiq seems to be TinyDI - https://code.google.com/p/tinydi/.\r\nIt recognises JSR330 Annotation but seems to lack the option of config files like \r\nthe simple properties file mechanism of dinistiq. Additionally - unlike Spring \r\nand dinistiq - it depends on public setters for the injections. Private members \r\nwith the @Inject annotation are not enough. Also it is fairly unmaintained for \r\nsome years now.\r\n\r\nAnother option I ran into is [Feather](https://github.com/zsoltherpai/feather)\r\ndescribed in [this article](http://codejargon.blogspot.no/2015/09/feather-ultra-lightweight-dependency.html).\r\nIt lacks too many injection options to be usefull for the injection scenarios \r\npresented here like injecting after instanciation with a @PostConstruct method \r\nto complete initialization.\r\n\r\n## History and Why\r\n\r\nI rather apologise to introduce another Dependency Injection Container for the \r\nJava world - dinistiq - a very minimalistic approach to the topic. It turned out \r\nto be easier to implement another one, than to use others listed here. Limited \r\nin features, easy to use, and still more configurable than other options I could \r\nthink of. After some months of use, I now can invite other users to take a look \r\nat it and try it in their own projects.\r\n\r\nAlso this text gives you a \"why\" on the use of the JSR 330 annotations for Dependency \r\nInjection. It simply makes your code even more reusable in case your development \r\nor deployment environment changes.\r\n\r\nSince tangram is much more about glueing together proven existing software \r\ncomponents and frameworks than writing code, I felt the need to check if the \r\nexisting code base was really fully dependent on the Spring Framework.\r\n\r\nDespite the fact that spring more or less in many ways does what I need, it \r\nsometimes feels a bit bloated and does too much magic I don't understand in \r\ndetail (which I still had to learn when debugging things). So I tried to isolate \r\nthe spring code during the tangram 0.9 work and present at least a second \r\nsolution for all the things I did with spring so far.\r\n\r\nFor tangram spring does three things\r\n\r\n- Dependency Injection to plug the whole application together\r\n- support a decent view layer with JSP and Apache Velocity views\r\n- A concise way to map http requests to code - controller classes or methods\r\n\r\nSo I took a look at other view frameworks like Vaadin, GWT, Apache Wicket, Play, \r\nStruts, JSF/JEE, Stripes. Right at the moment I think Vaading, GWT, Wicket, and \r\nPlay are no really good fit for tangram, Struts in my eyes is a fading technology, \r\nand only JSF/JEE is an obvious option. With Java Server Faces I only had \r\nunsatisfying project experiences and the rest of JEE goes for plain Servlet. So \r\ntangram had to be provided with a plain servlet way of doing the view layer.\r\n\r\nSince the modularity of tangram was achieved by the Spring way of plugging \r\ncomponents together with Dependency Injection, the first thing to do was, to mark \r\nthe generic components in a spring independent way and to look at the other \r\noptions for the Dependency Injection part. Only then it would be possible to \r\nreplace the spring view layer with a servlet view layer during the startup and \r\nwire-up of the application.\r\n\r\nSo the list of relevant DI frameworks gets shortened to those supporting the \r\ngeneric Dependency Injection annotations from JSR330 which are intended for JEE \r\nand can e.g. also be used with Google Guice and the Spring Framework alike.\r\n\r\nFrom the reading Google Guice seemed to be a good alternative for the proof of \r\nconcept phase, but it took me that much work to get something to run with it \r\n(not everything can be plugged together programmatically in my case), that I \r\ncame out faster with my own Dependency Injection Container. Rather minimalistic \r\nand only suited for the setup of components.\r\nresult\r\nIts advantage over Guice is that it's smaller and easier configurable with \r\nproperties files. Weeks later I discovered TinyDI as another option. While this \r\ncontainer seems to be a lot cleverer about the search of annotated classes it \r\nseems to lack the needed option of extending the configuration aspects from the \r\nannotations with properties files - defaults and overridden values and references.\r\n",
  "google": "UA-59511125-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}