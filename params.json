{"name":"Dinistiq","tagline":"Minimalistic Dependency Injection - Or: what I got wrong about dependency injection. dinistiq is a minimalistic approach to component based application setup done in Java. With only few external dependencies and a very small footprint it is based on the JSR 330 annotations for the Java SE using only one scope with mostly singletons.","body":"![dinistiq](https://raw.github.com/mgoellnitz/dinistiq/master/doc/dinistiq.png)\r\n\r\nMinimalistic Dependency Injection\r\n=================================\r\n\r\n[![Build Status](https://api.travis-ci.org/mgoellnitz/dinistiq.svg?branch=master)](https://travis-ci.org/mgoellnitz/dinistiq)\r\n[![Coverage Status](https://coveralls.io/repos/mgoellnitz/dinistiq/badge.svg)](https://coveralls.io/r/mgoellnitz/dinistiq)\r\n[![Dependency Status](https://www.versioneye.com/user/projects/54ff710b4a10649b1b000053/badge.svg?style=flat)](https://www.versioneye.com/user/projects/54ff710b4a10649b1b000053)\r\n\r\nA small footprint approach to dependency injection with a framework or container \r\nimplemented in Java.\r\n\r\nOr: What I got wrong about DI\r\n\r\nMinimalistic library to use dependency injection for the wire-up of software components. \r\nIt thus mostly deals with singletons - some of them implementing interfaces - which should \r\nbe injected as dependencies into one another.\r\n\r\nAs the only other option besides the single scope managed by dinistiq it allows for the \r\ncreation of fresh instances with all dependencies filled in from the scope of all beans\r\ncollected.\r\n\r\nFire up the wire up\r\n-------------------\r\n\r\nDinistiq scans a given portion of the classpath for classes annotated with JSR330 Annotations. \r\nIt does not introduce any custom annotations.\r\n\r\nThe missing bits can be configured by a set of properties files, describing\r\n\r\n- additional components that should be instanciated\r\n- additional values that should be injected into the instanciated components but cannot be derived from the autoscanned parts\r\n\r\nConvention over Configuration\r\n-----------------------------\r\n\r\nFirst of all the most important thing to use dinistiq is to annotate you dependencies with \r\nJSR @Inject so that dinistiq can find out which components are needed.\r\n\r\n```Java\r\npublic class TestComponentB {\r\n\r\n    @Inject\r\n    public TestInterface test;\r\n\r\n} // TestComponentB\r\n```\r\n\r\nIn the next step dinistiq resolves those components from the auto-scanned portion \r\nof the classpath where it instanciates all classes annotated with @Singleton. \r\nOptionally these components may be named with @Named (with an optional name as the \r\nvalue parameter). Without a name given as a parameter, components are always named\r\nafter their class name without the package name and a decapitalized first letter.\r\n\r\n```Java\r\n@Singleton\r\npublic class TestComponent implements TestInterface {\r\n\r\n} // TestComponent\r\n```\r\n\r\nThus in this example the instanciated bean of class TestComponent will be available \r\nwith the name testComponent. The term \"name\" is used in this document since it is \r\nused as the parameter name in the JSR330 annotations. Since names must be unique \r\nwithin the scope they are in this case in fact identifiers througout the whole process.\r\n\r\nIf you are dealing with components of the same type, not only the beans may be named \r\nbut also the injection point might indicate to require a bean with a certain name.\r\n\r\n```Java\r\npublic class ConfigStuff {\r\n\r\n    @Inject\r\n    @Named\r\n    public String filename;\r\n\r\n    @Inject\r\n    @Named(\"prefix\")\r\n    public String somePrefix;\r\n\r\n} // ConfigStuff\r\n```\r\n\r\nIn this case, filename is searched as a String component with the name \"filename\", \r\nwhile somePrefix has a specific named annotation with value \"prefix\".\r\n\r\nThis complete set-up is done without any configuration for dinistiq itself but only \r\nfor the components to be used.\r\n\r\nOptional Configuration with properties files\r\n--------------------------------------------\r\n\r\nIf this is not enough, you can explicitly add some beans to be instanciated in properties files.\r\n\r\n```\r\nunannotatedComponent=dinistiq.test.components.UnannotatedComponent\r\n```\r\n\r\nThose files must simply be put in the folder dinistiq/ anywhere on your classpath. \r\nThis example will instanciate the class dinistiq.test.components.UnannotatedComponent \r\nand store this bean with the name unannotatedComponent in the set of available beans.\r\n\r\nThe properties files are scanned in alphabetical order, so you can override the class \r\nfor e.g. unannotatedComponent in a latter properties file, so classes given for bean \r\nnames used in mybeans.properties can be overridden in override-mybeans.properties.\r\n\r\nFor any of the instanciated beans you can provide more values to explicitly inject - again \r\nby the use of properties files.\r\n\r\nAfter instanciation of the bean a properties file with the bean's name as its base \r\nfilename is searched - first in the dinistiq/defaults/ and then in the dinistiq/beans/ \r\nfolders on the classpath. Thus you can deliver your components with a reasonable \r\ndefaults and necessary overrides for the specific application.\r\n\r\nfile dinistiq/beans/example.properties\r\n```\r\nactivateCaching=true\r\n```\r\n\r\nThis will call the property setter setActivateCaching() on the bean named example. \r\nThe grammar of the properties files describing the explicit injection supports set\r\nand list type collections, boolean values, numeric value, strings, and references\r\nto other beans.\r\n\r\nfile dinistiq/beans/example.properties\r\n```\r\n# numerics\r\nintValue=42\r\nlongValue=123456789\r\nfloatValue=3.14159\r\ndoubleValue=2.7\r\n# references\r\ntestInterface=${testComponent}\r\n# strings and references in compound strings\r\nreplacement=a string\r\nreplacementTest=here comes ${replacement}\r\n```\r\n\r\nThe bean named example is either a result of the automatic discovery of a class named Example\r\n\r\n```Java\r\n@Named\r\n@Singleton\r\npublic class Example {\r\n\r\n} // Example\r\n```\r\n\r\na name declaration from the scanned class\r\n\r\n```Java\r\n@Named(\"example\")\r\n@Singleton\r\npublic class ExampleComponent  {\r\n\r\n} // ExampleComponent\r\n```\r\n\r\nor taken from the naming in a configuration properties file\r\n\r\nfile dinistiq/demo.properties\r\n```\r\nexample=some.package.ExampleComponent\r\n```\r\n\r\nAt the top level, the types of the beans cannot be inferred, as the example\r\n\r\n```\r\nunannotatedComponent=dinistiq.test.components.UnannotatedComponent\r\n```\r\n\r\nshowed. If you need some typical configuration types at this level - like e.g. Strings, \r\nBooleans, Lists, and Maps some extensions of this mere class based syntax had to be \r\nintroduced. Any simple type found in the java.lang package can be intanciated with a \r\nvalue bound to it since these values are immutable and there are thus no modifiable \r\nfields or setters in these classes.\r\n\r\nSo\r\n\r\n```\r\nbooleanValue=java.lang.Boolean(\"false\")\r\nstringValue=java.lang.String(\"string value\")\r\nintegerValue=java.lang.Integer(42)\r\n```\r\n\r\nare some examples for this. While\r\n\r\n```\r\nmapTest=java.util.Map\r\n```\r\n\r\ncreates and empty map instance. Like any other beans the contents of this map can \r\nbe modified by a properties file. In this case the contents of the properties file's\r\nkey / value pairs will be used as content for the whole map.\r\n\r\nLists of strings can be created by\r\n\r\n```\r\nlistTest=java.util.List(first,second)\r\n```\r\n\r\nHow to use\r\n----------\r\n\r\nExtend your project with the dependency to the rather small dinistiq library file. \r\nDinistiq releases are available from JCenter. The group id and artifact id are both \r\n'dinistiq'.\r\n\r\nThus for projects built with gradle you will need to add to your repositories sections \r\nof the build file the line\r\n\r\n```\r\njcenter()\r\n```\r\n\r\nif it's not there already and the dependency to the artifact in the dependencies section.\r\n\r\n```\r\ncompile \"dinistiq:dinistiq:0.5-SNAPSHOT\"\r\n```\r\n\r\nProjects built with Apache Maven need the following steps:\r\n\r\nmodule pom.xml\r\n```xml\r\n...\r\n<dependencies>\r\n  ...\r\n  <dependency>\r\n    <groupId>dinistiq</groupId>\r\n    <artifactId>dinistiq</artifactId>\r\n  </dependency>\r\n  ...\r\n</dependencies>\r\n```\r\n\r\nbase  pom.xml\r\n```xml\r\n...\r\n<dependencyManagement>\r\n  ...\r\n  <dependency>\r\n    <groupId>dinistiq</groupId>\r\n    <artifactId>dinistiq</artifactId>\r\n    <versions>0.5-SNAPSHOT</version>\r\n  </dependency>\r\n...\r\n</dependencyManagement>\r\n\r\n...\r\n\r\n<repositories>\r\n  <repository>\r\n    <id>jcenter</id>\r\n    <name>JCenter</name>\r\n    <url>http://jcenter.bintray.com/</url>\r\n  </repository>\r\n</repositories>\r\n...\r\n```\r\n\r\nDinistiq uses slf4j for logging and (still) log4j as an instance for testing.\r\n\r\nSnapshot artifacts are available from the OJO repository:\r\n\r\n```\r\nhttps://oss.jfrog.org/\r\n```\r\n\r\nApart from optional configuration files to be placed somehere on your classpath, \r\nyou simply have to tell dinistiq which portion of the classpath to scan for annotations.\r\n\r\n```Java\r\npublic class Test  {\r\n\r\n    public static main(String[] args) {\r\n        Set<String> packages = new HashSet<String>();\r\n        packages.add(Test.class.getPackage().getName());\r\n        Dinistiq d = new Dinistiq(packages);\r\n    } // main()\r\n\r\n} // Test\r\n```\r\n\r\nMake this portion of the classpath as small as ever possible or point to some invented \r\nand thus empty package, if you want to avoid scanning.\r\n\r\nAfter this step you can ask dinistiq for instances of the components it created and \r\ninjected.\r\n\r\n```Java\r\npublic class Test  {\r\n\r\n    public static main(String[] args) {\r\n        Set<String> packages = new HashSet<String>();\r\n        packages.add(Test.class.getPackage().getName());\r\n        Dinistiq d = null;\r\n        try {\r\n            d = new Dinistiq(packages);\r\n        } catch (Exception e) {\r\n            //\r\n        } // try/catch\r\n        TestInterface ti = d.findTypedBean(TestInterface.class);\r\n        TestInterface test = d.findBean(TestInterface.class, \"test\");\r\n        Set<TestInterface> tis = d.findTypedBeans(TestInterface.class);\r\n    } // main()\r\n\r\n} // Test\r\n```\r\n\r\nWeb embedding\r\n-------------\r\n\r\nDinistiq comes with a very lean web integration. An ordered list of beans implementing\r\nthe servlet interface will be added to the web application context using injection\r\nand serving web requests.\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n         version=\"2.5\">\r\n  \r\n  <display-name>dinistiq.web</display-name>\r\n\r\n  <listener>\r\n    <listener-class>dinistiq.web.DinistiqContextLoaderListener</listener-class>\r\n  </listener>\r\n  <context-param>\r\n    <param-name>dinistiq.packages</param-name>\r\n    <param-value>com.example.components,org.example.components</param-value>\r\n  </context-param>\r\n  \r\n  <welcome-file-list>\r\n    <welcome-file>index.html</welcome-file>\r\n  </welcome-file-list>\r\n\r\n</web-app>\r\n```\r\n\r\nThe context loader listener tries to find the other servlets from the dinistiq context \r\nby asking for registrable servlets. \r\n\r\n```Java\r\n/**\r\n * Servlets which should handle requests fulfilling a certain regular expression for their uris.\r\n */\r\npublic interface RegisterableServlet extends Servlet, Comparable<RegisterableServlet> {\r\n\r\n    /**\r\n     * Returns a set of url patterns this servlet should be registered for.\r\n     */\r\n    Set<String> getUrlPatterns();\r\n\r\n    /**\r\n     * Indicator if the implementing instance should be considered earlier or later \r\n     * in the servlet selection process.\r\n     */\r\n    int getOrder();\r\n\r\n} // RegisterableServlet\r\n```\r\n\r\nSo a servlet has to tell which url patterns its request should meet to be able to \r\nhandle them. Additionally it tells an order number to sort all available servlets \r\nto provide a certain precedency rule for them.\r\n\r\nCustom Class Resolver\r\n---------------------\r\n\r\nIt is perfectly possible that you will find our class resolving pretty dumb. So we \r\nprovide the option to pass over a class resolver instance to dinistiq instead of the \r\nset of package names.\r\n\r\n```Java\r\npublic class Test  {\r\n\r\n    public static main(String[] args) {\r\n        Set<String> packages = new HashSet<String>();\r\n        packages.add(Test.class.getPackage().getName());\r\n        packages.add(Dinistiq.class.getPackage().getName());\r\n        Dinistiq d = null;\r\n        ClassResolver classResolver = new BetterClassResolver(packages);\r\n        try {\r\n            d = new Dinistiq(classResolver);\r\n        } catch (Exception e) {\r\n            //\r\n        } // try/catch\r\n    } // main()\r\n\r\n} // Test\r\n```\r\n\r\nBe sure to add the package dinistiq in these cases as shown above. Otherwise for obvious \r\nreasons the properties files from the dinistiq path cannot be found as resources to \r\nbe taken into consideration.\r\n\r\nIf you want to use custom class resolvers with the web integration you need to implement\r\na class resolver taking the set of package names as the single parameter to the constructor\r\nand put the name of this implementing class in the context loader listener configuration\r\nfor dinistiq.\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n         version=\"2.5\">\r\n  \r\n  <display-name>dinistiq.web</display-name>\r\n\r\n  <listener>\r\n    <listener-class>dinistiq.web.DinistiqContextLoaderListener</listener-class>\r\n  </listener>\r\n  <context-param>\r\n    <param-name>dinistiq.packages</param-name>\r\n    <param-value>com.example.components,org.example.components</param-value>\r\n  </context-param>\r\n  <context-param>\r\n    <param-name>dinistiq.class.resolver</param-name>\r\n    <param-value>org.example.dinistiq.BetterClassResolver</param-value>\r\n  </context-param>\r\n  \r\n  <welcome-file-list>\r\n    <welcome-file>index.html</welcome-file>\r\n  </welcome-file-list>\r\n\r\n</web-app>\r\n```\r\n\r\nWithin the web application all beans from the dinistiq scope are available in the\r\napplication scope (servlet context) as attributes.\r\n\r\nExternal Components\r\n-------------------\r\n\r\nIf your software needs to use some components which cannot be instanciated or obtained \r\nusing all of the means presented here, you can pass over a named set of instances as \r\na base set of beans for dinistiq to add the scanned and configured beans to.\r\n\r\nWe use this to e.g. put the servlet context in the set of beans for web integration \r\n(see below).\r\n\r\n```Java\r\npublic class DinistiqContextLoaderListener implements ServletContextListener {\r\n\r\n    @Override\r\n    public void contextInitialized(ServletContextEvent contextEnvironment) {\r\n        ServletContext context = contextEnvironment.getServletContext();\r\n        Set<String> packages = new HashSet<String>();\r\n        ...\r\n        try {\r\n            Map<String, Object> externalBeans = new HashMap<String, Object>();\r\n            externalBeans.put(\"servletContext\", context);\r\n            Dinistiq dinistiq = new Dinistiq(packages, externalBeans);\r\n            context.setAttribute(DINISTIQ_INSTANCE, dinistiq);\r\n        } catch (Exception ex) {\r\n            LOG.error(\"init()\", ex);\r\n        } // try/catch\r\n    } // contextInitialized()\r\n\r\n} // DinistiqContextLoaderListener\r\n```\r\n\r\nBesides the one managed Scope\r\n-----------------------------\r\n\r\nDinistiq defines just one scope of beans you can grab beans from. If you need fresh \r\ninstances of beans where the members of this scope should be injected on creation and \r\noptional post construct methods should be called just following the same rules as \r\nthe beans from the dinistiq scope, you will find a createBeans method besides all \r\nthe options to find existing beans in the scope.\r\n\r\n```Java\r\nMy myNewInstance = dinistiq.createBean(My.class, null);\r\n```\r\n\r\nIf this is still no option, you can - like with external beans - provide instances \r\nexternally and let dinistiq still handle their injections and post construct methods.\r\n\r\n```Java\r\nMy myNewInstance = new My();\r\ndinistiq.initBean(myNewInstance, null);\r\n```\r\n\r\nBuilding\r\n--------\r\n\r\nThe code for dinistiq is supposed to be written in Java 7 and prepared for building \r\nwith gradle. Gradle versions 1.12 up to 2.4 are tested to be working.\r\n\r\nWhile dinistiq 0.4 happily works with Java 8, only dinistiq 0.5 and up can be compiled\r\nand tested with Java 8.\r\n\r\nComparison\r\n----------\r\n\r\nThe developers of [silk] (http://www.silkdi.com/help/comparison.html) present an \r\ninteresting comparison of some DI implementations done in Java and we want to add \r\nsome  values for dinistiq to this list:\r\n\r\n|Library|dinistiq|\r\n|:------|-------:|\r\n|Version|0.4|\r\n|Archive size|<25kB|\r\n|Further dependencies|<=5|\r\n|API||\r\n|Methods in injector/context|3|\r\n|Concept||\r\n|Container Model|flat instances|\r\n|Configuration style|annotation,properties|\r\n|Wiring style|automatic scan|\r\n|Types||\r\n|Generics support|limitted|\r\n|Generic type safety|-|\r\n|Wildcard generics|-|\r\n|Primitive types handling|-|\r\n|Bind to all (generic) supertypes|yes|\r\n|Type link|-|\r\n|Injection||\r\n|Annotation guidance|only JSR330|\r\n|Constructor injection|yes|\r\n|Field injection|yes|\r\n|Setter injection|yes|\r\n|Factory methods|no|\r\n|Static injection|no|\r\n|Method interception|no|\r\n|Providers|(limited)|\r\n|Optional injection|no|\r\n|Mixed injection|?|\r\n|Post construction hook|yes|\r\n|Modularity||\r\n|Arrays|no|\r\n|Collections|partly|\r\n|Multibinds|yes|\r\n|Sequence of declarations|undefined|\r\n|Scopes||\r\n|Default scope|Singleton|\r\n|Custom scopes|-|\r\n|Available scopes|Singleton|\r\n|Error behaviour||\r\n|Dependency cycles|illegal|\r\n|Detection of a cyclic dependencies error|runtime|\r\n\r\nThe closest competitor of dinistiq seems to be TinyDI - https://code.google.com/p/tinydi/. \r\nIt recognises JSR330 Annotation but seems to lack the option of config files like the \r\nsimple properties file mechanism of dinistiq. Additionally - unlike Spring and dinistiq - \r\nit depends on public setters for the injections. Private members with the @Inject annotation\r\nare not enough. Also it is fairly unmaintained for some years now.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}